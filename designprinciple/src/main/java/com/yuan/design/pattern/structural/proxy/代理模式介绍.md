定义与类型：
	定义：
		1、为其他对象提供一种代理，以控制对这个对象的访问
		2、补充：代理对象在客户端和目标对象之间起到一个中介的作用。
	类型：结构型
适用场景：
	保护目标对象
	增强目标对象
优点：
	1、代理模式能将代理对象与真实被调用的目标对象分离。
	2、一定程度上降低了系统的耦合度，扩展性好。
	3、保护目标。
	4、增强目标对象。
缺点：
	1、代理模式会造成系统设计中类的数目的增加。
	2、在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢。
	3、增加了系统的复杂度。
扩展：
	1、静态代理。（具体实现类代理）
	2、动态代理。（只能接口代理。）
	3、CGLib代理。（针对类实现进行代理。继承和重写，所以对于final修饰符要格外关注，能否被继承。）
总结：
	静态代理：
		在代码中显式的定义了一个业务实现类的一个代理。在代理类中对同名的方法进行包装。用户通过调用代理类的被包装过的业务方法来调用目标对象的业务方法，同时对目标对象的业务方法进行增强。
	动态代理：
		是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法。
	CGLib代理：
		是通过继承来实现的，生成的动态代理类是就是业务类的子类，然后通过重写业务方法进行代理。
Spring代理选择——扩展。
	1、当Bean有实现接口时，Spring就会用JDK的动态代理。
	2、当Bean没有实现接口时，Spring使用CGLib。
	3、可以强制使用CGLib。
		1。在Spring配置中加入<aop:aspectj-autoproxy proxy-target-class='true'/>
	4、参考资料：https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html
	
代理速度对比——扩展：
	1、CGLib
	2、JDK动态代理
	3、速度对比 
	大数据量代理：jdk动态代理>CGLib代理。
代理模式——相关设计模式：
	1、代理模式和装饰者模式：实现比较相似，但是目的不同：装饰者模式是为对象加上行为，代理模式是控制访问，代理模式更加注重通过设置代理人的方式来增强目标对象，一般是增强目标对象的某些行为。
	2、代理模式和适配器模式：适配器模式主要改变所考虑目标对象的接口，而代理模式是不能改变所代理目标对象的接口的。
